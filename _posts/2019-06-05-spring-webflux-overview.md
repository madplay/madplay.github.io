---
layout:   post
title:    "스프링 웹플럭스 레퍼런스: 1. 스프링 웹플럭스(Spring Webflux)"
author:   Kimtaeng
tags: 	  spring webflux reactive
description: "Spring Webflux References: 1. Spring Webflux"
category: Spring
date: "2019-06-05 00:01:24"
comments: true
---

# 1. 스프링 웹플럭스(Spring Webflux)
스프링 프레임워크의 기존 웹 프레임워크인 스프링 웹 MVC는 서블릿(Servlet) API와 서블릿 컨테이너를 위한 목적으로 개발되었다. 
한편 리액티브 스택 웹 프레임워크인 스프링 웹 플럭스는 5.0 버전에 추가되었다. 이는 완전한 논 블로킹이며 리액티브 스트림 배압(Backpressure)을 지원하고
네티, 언더토우 그리고 서블릿 3.1 버전 이상 컨테이너와 같은 서버 등에서 실행된다.

두 프레임워크 모두 소스 모듈(스프링 웹 MVC와 스프링 웹플럭스)의 이름을 잘 반영하고 있으며 스프링 프레임워크에 나란히 존재한다.
각 모듈은 선택적이다. 애플리케이션은 하나 또는 다른 모듈을 사용하거나 경우에 따라서 둘 다 사용할 수 있다. (예를 들면 리액티브 `WebClient`가 있는
스프링 MVC 컨트롤러)

## 1.1 개요(Overview)
스프링 웹플럭스는 왜 만들어졌을까?

이 의문에 대한 답의 일부는 적은 수의 스레드로 동시성을 처리하고 더 적은 하드웨어 리소스로 확장하기 위해 논 블로킹 웹 스택이 필요하다는 것이다.
서블릿 3.1은 논 블로킹 I/O를 위한 API를 제공했다. 하지만 이를 사용하면 Filter, Servlet과 같은 동기(synchronous)식과 `getParameter`,
`getPart` 등의 블로킹(blocking) 방식같은 다른 서블릿 API와의 어울리지 못한다. 이것이 논 블로킹 실행환경에서 기반 역할을 하는 새로운 공통 API가
탄생하게된 동기다. 이점은 비동기, 논 블로킹이 잘 확립된 서버(예를 들면 Netty) 때문에 중요하다.

또다른 탄생 배경은 함수형 프로그래밍(functional programming)이다. 자바 5에 어노테이션을 추가한 것처럼(어노테이션이 붙은 Rest 컨트롤러, 단위 테스트)
자바 8에서 추가된 람다 표현식은 자바의 기능적인 API를 위한 기회를 만들었다. 람다 표현식은 비동기 로직을 서술적으로 작성할 수 있게 하는 논 블로킹
애플리케이션과 연속형 API(예를 들면 `CompletableFuture`, `ReactiveX`)에게 도움이 된다. 프로그래밍 모델 레벨에서 자바 8은 스프링 웹플럭스가
어노테이션 달린 컨트롤러와 함께 기능적인 웹 엔드포인트를 제공하도록 했다.

### 1.1.1 "리액티브" 정의(Define "Reactive")
앞서 "논 블로킹(non-blocking)"과 "기능적(functional)"에 대해서 언급했다. 그런데 리액티브는 무엇을 의미할까?

"리액티브(reactive)"란 용어는 I/O 이벤트에 반응하는 네트워크 요소, 마우스 이벤트에 반응하는 UI 컨트롤러 등 변화에 반응하는 것을 중점으로 둔
프로그래밍 모델을 말한다. 그런 의미에서 논 블로킹(non-blocking)은 리액티브다. 이유는 블로킹되지 않고 작업이 완료되거나 데이터가 사용 가능해짐 등과 같은
알림에 반응하기 때문이다.

스프링 팀이 "리액티브"와 연관시키는 또 다른 중요한 매커니즘이 있는데 그것은 논 블로킹 백프레셔(back pressure)다. 동기식(synchronous), 명령형 코드,
블로킹 호출은 호출자를 대기하게 하는 자연스러운 형태의 백프레셔 역할을 한다. 논 블로킹 코드에서는 바른 생산자가 목적지(소비자)를 압도하지 않도록
이벤트의 속도를 제어하는 것이 중요해진다.

리액티브 스트림은 백프레셔를 통해 비동기 컴포넌트 사이의 상호 작용을 정의하는 작은 스펙(자바 9에서 채택된)이다. 예를 들어, 데이터 저장소(발행자 역할)는
HTTP 서버(구독자 역할)가 응답에 사용할 수 있는 데이터를 생성할 수 있다. 리액티브 스트림의 주요 목적은 구독자를 통해 발행자가 데이터를 얼마나 빠르게 또는
얼마나 느리게 생산할지 제어하도록 하는 것이다.

> **일반적인 질문: 만일 발행자가 속도를 늦출 수 없다면 어떻게 해야 할까?**<br>
리액티브 스트림의 목적은 오직 매커니즘과 경계를 설정하는 것이다. 발행자가 속도를 늦출 수 없는 경우에는 버퍼 사용, 버림(drop) 또는 실패(fail)할지
결정해야 한다.

### 1.1.2 리액티브 API(Reactive API)
리액티브 스트림은 시스템의 상호 정보 교환성(interoperability)에 있어서 중요한 역할을 한다. 라이브러리 및 인프라 구성 요소에는 그렇지만
너무 로우 레벨이기 때문에 애플리케이션 API로서 덜 유용하다. 애플리케이션은 비동기 로직을 구성하기 위하여 더 높고 풍부한 함수형 API를 필요하며,
이는 자바 8 스트림 API와 유사하지만 컬렉션에 대해서만 필요한 것은 아니다. 이것이 리액티브 라이브러리의 역할이다.

리액터(Reactor)는 스프링 웹플럭스가 선택한 리액티브 라이브러리다. 리액터는 ReactiveX의 풍부한 연산자 세트를 통해 0..1(`Mono`)과 0..N(`Flux`) 형태의
데이터를 작업할 수 있는 `Mono`와 `Flux` API 유형을 제공한다. 리액터는 리액티브 스트림 라이브러리이므로 모든 리액터 연산자는 논 블로킹 백프레셔를 지원한다.
리액터는 서버측 자바에 중점을 두고 있으며 스프링과 긴밀히 협력하여 개발되었다.

웹플럭스는 리액터에 핵심 의존성을 갖지만 리액티브 스트림을 통해 다른 리액티브 라이브러리들과 상호 운용이 가능하다. 일반적으로 웹플럭스 API는 일반적인
발행자를 입력으로 받고 이를 내부적으로 리액터 타입에 맞추어 적용하고, 이를 사용하고, `Flux` 또는 `Mono`를 출력으로 반환한다.

따라서 어떤 발행자(`Publisher`)든 입력으로 전달하여 반환값에 대한 연산을 적용할 수 있지만 다른 리액티브 라이브러리와 사용하려면 반환 형태를 맞추어야 한다.
웹플럭스는 가능할때마다(예를 들어, 어노테이션이 붙은 컨트롤러) RxJava 또는 다른 리액티브 라이브러리와 쉽게 적용될 수 있다.
자세한 내용은 리액티브 라이브러리를 참조하라.

> 리액티브 API 외에도, 웹플럭스는 코틀린의 코루틴 API와 함께 사용되어 보다 명령형 스타일로 프로그래밍할 수 있다. 이후에 등장하는 코틀린 코드 샘플은
코루틴 API와 함께 제공된다.

### 1.1.3 프로그래밍 모델(Programming Models)
스프링 웹(`spring-web`) 모듈에는 HTTP 추상화, 지원되는 서버를 위한 리액티브 스트림 어댑터, 코덱 그리고 서블릿 API와 유사하지만 논 블로킹 계약을 포함하는
핵심 웹 핸들러(`WebHandler`) API를 포함하여 스프링 웹 플럭스의 근본이 되는 리액티브 기반이 포함되어 있다.

이를 바탕으로 스프링 웹플럭스는 두 가지 프로그래밍 모델 중에서 선택할 수 있도록 한다.

- **어노테이션 달린 컨트롤러(Annotated Controller)**: 스프링 MVC와 일치하며, `spring-web` 모듈과 동일한 어노테이션을 기반으로 한다.
스프링 MVC와 웹플럭스 컨트롤러는 리액티브(리액터와 RxJava) 반환 타입을 지원하므로 이를 구분하기가 쉽지 않다. 주목할만한 차이점 중 하나는 웹플럭스 또한
리액티브 `@RequestBody` 인수(arguments)를 지원한다는 것이다.

- **함수형 엔드포인트(Functional Endpoints)**: 람다 기반의 가벼운 함수형 프로그래밍 모델이다. 애플리케이션이 요청을 라우팅하고 처리하는데 사용할 수 있는
작은 라이브러리 또는 유틸리티 집합이라고 생각할 수 있다. 어노테이션 컨트롤러와의 큰 차이점은 애플리케이션이 어노테이션을 통해 의도를 선언하고 콜백을 받는 것과
다르게 요청을 처음부터 끝까지 처리한다는 점이다.