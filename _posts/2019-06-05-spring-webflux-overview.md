---
layout:   post
title:    "스프링 웹플럭스 레퍼런스: 1. 스프링 웹플럭스(Spring Webflux)"
author:   Kimtaeng
tags: 	  spring webflux reactive
description: "Spring Webflux References: 1. Spring Webflux"
category: Spring
date: "2019-06-05 00:01:24"
comments: true
---

# 1. 스프링 웹플럭스(Spring Webflux)
스프링 프레임워크의 기존 웹 프레임워크인 스프링 웹 MVC는 서블릿(Servlet) API와 서블릿 컨테이너를 위한 목적으로 개발되었다. 
한편 리액티브 스택 웹 프레임워크인 스프링 웹 플럭스는 5.0 버전에 추가되었다. 이는 완전한 논 블로킹이며 리액티브 스트림 배압(Backpressure)을 지원하고
네티, 언더토우 그리고 서블릿 3.1 버전 이상 컨테이너와 같은 서버 등에서 실행된다.

두 프레임워크 모두 소스 모듈(스프링 웹 MVC와 스프링 웹플럭스)의 이름을 잘 반영하고 있으며 스프링 프레임워크에 나란히 존재한다.
각 모듈은 선택적이다. 애플리케이션은 하나 또는 다른 모듈을 사용하거나 경우에 따라서 둘 다 사용할 수 있다. (예를 들면 리액티브 `WebClient`가 있는
스프링 MVC 컨트롤러)

## 1.1 개요(Overview)
스프링 웹플럭스는 왜 만들어졌을까?

이 의문에 대한 답의 일부는 적은 수의 스레드로 동시성을 처리하고 더 적은 하드웨어 리소스로 확장하기 위해 논 블로킹 웹 스택이 필요하다는 것이다.
서블릿 3.1은 논 블로킹 I/O를 위한 API를 제공했다. 하지만 이를 사용하면 Filter, Servlet과 같은 동기(synchronous)식과 `getParameter`,
`getPart` 등의 블로킹(blocking) 방식같은 다른 서블릿 API와의 어울리지 못한다. 이것이 논 블로킹 실행환경에서 기반 역할을 하는 새로운 공통 API가
탄생하게된 동기다. 이점은 비동기, 논 블로킹이 잘 확립된 서버(예를 들면 Netty) 때문에 중요하다.

또다른 탄생 배경은 함수형 프로그래밍(functional programming)이다. 자바 5에 어노테이션을 추가한 것처럼(어노테이션이 붙은 Rest 컨트롤러, 단위 테스트)
자바 8에서 추가된 람다 표현식은 자바의 기능적인 API를 위한 기회를 만들었다. 람다 표현식은 비동기 로직을 서술적으로 작성할 수 있게 하는 논 블로킹
애플리케이션과 연속형 API(예를 들면 `CompletableFuture`, `ReactiveX`)에게 도움이 된다. 프로그래밍 모델 레벨에서 자바 8은 스프링 웹플럭스가
어노테이션 달린 컨트롤러와 함께 기능적인 웹 엔드포인트를 제공하도록 했다.

### 1.1.1 "리액티브" 정의
앞서 "논 블로킹(non-blocking)"과 "기능적(functional)"에 대해서 언급했다. 그런데 리액티브는 무엇을 의미할까?

"리액티브(reactive)"란 용어는 I/O 이벤트에 반응하는 네트워크 요소, 마우스 이벤트에 반응하는 UI 컨트롤러 등 변화에 반응하는 것을 중점으로 둔
프로그래밍 모델을 말한다. 그런 의미에서 논 블로킹(non-blocking)은 리액티브다. 이유는 블로킹되지 않고 작업이 완료되거나 데이터가 사용 가능해짐 등과 같은
알림에 반응하기 때문이다.

스프링 팀이 "리액티브"와 연관시키는 또 다른 중요한 매커니즘이 있는데 그것은 논 블로킹 백프레셔(back pressure)다. 동기식(synchronous), 명령형 코드,
블로킹 호출은 호출자를 대기하게 하는 자연스러운 형태의 백프레셔 역할을 한다. 논 블로킹 코드에서는 바른 생산자가 목적지(소비자)를 압도하지 않도록
이벤트의 속도를 제어하는 것이 중요해진다.

리액티브 스트림은 백프레셔를 통해 비동기 컴포넌트 사이의 상호 작용을 정의하는 작은 스펙(자바 9에서 채택된)이다. 예를 들어, 데이터 저장소(발행자 역할)는
HTTP 서버(구독자 역할)가 응답에 사용할 수 있는 데이터를 생성할 수 있다. 리액티브 스트림의 주요 목적은 구독자를 통해 발행자가 데이터를 얼마나 빠르게 또는
얼마나 느리게 생산할지 제어하도록 하는 것이다.

> **일반적인 질문: 만일 발행자가 속도를 늦출 수 없다면 어떻게 해야 할까?**<br>
리액티브 스트림의 목적은 오직 매커니즘과 경계를 설정하는 것이다. 발행자가 속도를 늦출 수 없는 경우에는 버퍼 사용, 버림(drop) 또는 실패(fail)할지
결정해야 한다.